<div>
    <a hx-get="{% url 'board-list' %}" hx-target="#board-list" hx-push-url="/boards">back to boards</a>
    <div class="container-fluid">
        <h1>Serialization demo</h1>
        <a onclick="saveGrid()" class="btn btn-primary" href="#">Save</a>
        <a onclick="loadGrid()" class="btn btn-primary" href="#">Load</a>
        <a onclick="saveFullGrid()" class="btn btn-primary" href="#">Save Full</a>
        <a onclick="loadFullGrid()" class="btn btn-primary" href="#">Load Full</a>
        <a onclick="clearGrid()" class="btn btn-primary" href="#">Clear</a>
        <a onclick="addWidget()" class="btn btn-primary" href="#">Add Widget</a>
        <br /><br />
        <div id="gridCont">
            <div class="grid-stack"></div>
        </div>
        <textarea id="saved-data" style="width: 100%" cols="100" rows="20" readonly="readonly"></textarea>
    </div>
    <script type="text/javascript">
        // NOTE: REAL apps would sanitize-html or DOMPurify before blinding setting innerHTML. see #2736
        GridStack.renderCB = function (el, w) {
            el.innerHTML = w.content;
        };
        let serializedData = {{serialized_elements | safe}};
        serializedData.forEach((n, i) => {
            //n.id = String(i);
            n.content = `<button onclick="removeWidget(this.parentElement.parentElement)">X</button><br> ${n.id}<br> ${n.content ? n.content : ''}`;
        });
        let serializedFull;

        let grid = GridStack.init({
            minRow: 1, // don't let it collapse when empty
            cellHeight: 80,
            float: true,
            draggable: {cancel: '.no-drag'} // example of additional custom elements to skip drag on
        }).load(serializedData);
        addEvents(grid);

        // 2.x method - just saving list of widgets with content (default)
        function loadGrid() {
            grid.load(serializedData);
        }

        // 2.x method
        function saveGrid() {
            delete serializedFull;
            serializedData = grid.save();
            document.querySelector('#saved-data').value = JSON.stringify(serializedData, null, '  ');
        }

        // 3.1 full method saving the grid options + children (which is recursive for nested grids)
        function saveFullGrid() {
            serializedFull = grid.save(true, true);
            serializedData = serializedFull.children;
            document.querySelector('#saved-data').value = JSON.stringify(serializedFull, null, '  ');
        }

        // 3.1 full method to reload from scratch - delete the grid and add it back from JSON
        function loadFullGrid() {
            if (!serializedFull) return;
            grid.destroy(true); // nuke everything
            grid = GridStack.addGrid(document.querySelector('#gridCont'), serializedFull)
        }

        function clearGrid() {
            grid.removeAll();
        }

        function removeWidget(el) {
            // TEST removing from DOM first like Angular/React/Vue would do
            el.remove();
            grid.removeWidget(el, false);
        }

        function addWidget() {
            let n = {
                w: Math.round(1 + 3 * Math.random()),
                h: Math.round(1 + 3 * Math.random()),
                content: '<button onClick="grid.removeWidget(this.parentNode.parentNode)">X</button><br>',
            };
            grid.addWidget(n);
        };

        // event listener for grid moved widget
        function addEvents(grid) {
            grid.on('added', function (e, items) {
                console.log('added', items);
            });
            grid.on('change', function (e, items) {
                console.log('change', items);
            });
            grid.on('removed', function (e, items) {
                console.log('removed', items);
            });
        }

    </script>
</div>
